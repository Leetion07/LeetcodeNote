[TOC]
## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
### 迭代思路
迭代思路：用栈来模拟递归，那么就是把root->left->left全部放入stack里，直到遇到null，此时需要把栈顶元素进行收集，因为此时到达了中序部分，然后，把当前的指针cur指向top()->right进行右子树的遍历。

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```
### 递归思路

```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        traversal(cur->left, vec);  // 左
        vec.push_back(cur->val);    // 中
        traversal(cur->right, vec); // 右
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```
## [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)
### 思路
1. 确定递归函数的参数和返回值： 
- 参数为可取数字的范围。
- 返回值该范围的数字可以组成的所有搜索二叉树的组合
2. 确定终止条件： 
可以取数字的范围不存在时，只有一种选择，即为空。
3. 确定单层递归的逻辑： 
对于左右的vector进行遍历，进行组合可以得到所有情况。双层for循环即可
4. 这是否还要备忘录，按理说有重复子集，但是主要是底层TreeNode的拷贝构造函数是值拷贝还是内存拷贝，这是不确定的。因此不建议用吧

```cpp
class Solution {
public:
    vector<TreeNode*> traverse(int left, int right) {
        vector<TreeNode*> result;
        if (left > right) {
            return {nullptr};
        } else if (left == right) {
            return {new TreeNode(left)};
        }
        for (int i = left; i <= right; ++i) {
            vector<TreeNode*> lRoot = traverse(left, i - 1);
            vector<TreeNode*> rRoot = traverse(i + 1, right);
            for (auto &l: lRoot) {
                for (auto &r: rRoot) {
                    TreeNode *root = new TreeNode(i);
                    root->left = l;
                    root->right = r;
                    result.push_back(root);
                }
            }
        }
        return result;
    }
    vector<TreeNode*> generateTrees(int n) {
        return traverse(1, n);
    }
};
```

## [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)
### 思路
1. 确定递归函数的参数和返回值： 
- 参数为可取数字的范围。
- 返回值为可以构成的不同二叉搜索树的个数
2. 确定终止条件： 
可以取数字的范围不存在时，只有一种选择，即为空。
3. 确定单层递归的逻辑： 
根据左边和右边的个数可以得到个数
4. 需要备忘录记录，否则会超时

```cpp
class Solution {
public:
    vector<vector<int>> record; // 记录 已经遍历过的子问题
    int traverse(int left, int right) {
        if (left >= right) {
            return 1;
        }
        if (record[left - 1][right - 1] != -1) {
            return record[left - 1][right - 1];
        }
        int sum = 0;
        for (int i = left; i <= right; ++i) {
            int lRes = traverse(left, i - 1);
            int rRes = traverse(i + 1, right);
            sum += lRes * rRes;
        }
        record[left - 1][right - 1] = sum;
        return sum;
    }

    int numTrees(int n) {
        record.resize(n, vector<int>(n, -1));
        return traverse(1, n);
    }
};
```
## [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)
### 思路 
首先有一个判断准则，那就是左子树的所有元素要小于根节点，右子树的所有元素要大于根节点。
那么就需要时刻去存储最大值和最小值。
1. 确定递归函数的参数和返回值： 
- 参数为该结点需要满足的上下界。
- 返回值为是否满足要求
2. 确定终止条件： 
如果为空的话，则一定为true。
3. 确定单层递归的逻辑： 
判断左右是否满足要求即可。

```cpp
class Solution {
public:
    bool traverse(TreeNode *root, long long min, long long max) {
        if (root == nullptr) {
            return true;
        }
        if (root->val <= min || root->val >= max) {
            return false;
        }
        return traverse(root->left, min, root->val) && traverse(root->right, root->val, max);
    }
    bool isValidBST(TreeNode* root) {
        return traverse(root, LONG_MIN, LONG_MAX);
    }
};
```

## [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)
### 思路
在中序遍历期间记录需要交换的两个结点即可。如下两种case，相邻或不相邻。
如果是相邻的话： 只会进入一次。
如果不相邻的话： 会进入两次，first第一次记录，second 第二次记录。
![image.png](https://note.youdao.com/yws/res/3476/WEBRESOURCEea3ef50ed764acdc8a5b8b4fa238aac6)
```cpp
class Solution {
public:
    TreeNode *prev = new TreeNode(INT_MIN), *first = nullptr, *second = nullptr;
    void inorderTraverse(TreeNode *root) {
        if (root == nullptr) {
            return;
        } 
        inorderTraverse(root->left);
        if (root->val < prev->val) {
            /*两种case，需要交换的结点相邻或是不相邻*/
            /*若进入一次则刚好为prev 和 root 结点*/
            /*若进入第二次，只需要改变second即可*/
            if (first == nullptr) {
                first = prev;
            }   
            second = root;
        }    
        prev = root;
        inorderTraverse(root->right);
    }
    void recoverTree(TreeNode* root) {
        inorderTraverse(root);
        swap(first->val, second->val);
    }
};
```

## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)
### 思路
进行前序遍历即可，比较是否相等。
```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == nullptr && q == nullptr) {
            return true;
        } else if (p != nullptr && q != nullptr) {
            if (p->val != q->val) {
                return false;
            }
            if (isSameTree(p->left, q->left) && isSameTree(p->right, q->right)) {
                return true;
            }
        }
        return false;
    }
};
```
## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)
### 思路
主要是比较左右子树的对应位置的值是否相等。左右子树同步的进行深度搜索，左子树的搜索为先中后左再右，右子树的搜索为先中后右再左。
对应的结点情况，如果都为空则返回true， 一空一不为空则为false，都不为空但是值不等为false，其余的话就继续深度搜索。

```cpp
class Solution {
private:
    bool traverse(TreeNode *lRoot, TreeNode *rRoot) {
        if (lRoot == nullptr && rRoot == nullptr) {
            return true;
        } else if (lRoot != nullptr && rRoot !=nullptr && lRoot->val != rRoot->val) {
            return false;
        } else if (lRoot != nullptr && rRoot == nullptr || lRoot == nullptr && rRoot != nullptr){
            return false;
        }
        if (traverse(lRoot->left, rRoot->right) && traverse(lRoot->right, rRoot->left)) {
            return true;
        } 
        return false;
    }
public:
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) return true;
        return traverse(root->left, root->right);
    }
};
```

## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
### 思路
层序遍历就是一层一层从左到右进行，需要队列数据接口作为辅助
![image](https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif)
具体步骤：先将root结点放入队列。
然后for循环现有的所有队中元素，及对应该层的数量，每弹出一个则将它的左右子树加入进去形成新的队列。
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> result;
        if (root == nullptr) return {};
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> resLevel;
            for (int i = 0; i < size; ++i) {
                TreeNode *cur = que.front();
                que.pop();
                resLevel.push_back(cur->val);
                if (cur->left != nullptr) que.push(cur->left);
                if (cur->right != nullptr) que.push(cur->right);
            }
            result.push_back(resLevel);
        }
        return result;
    }
};
```
## [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)
### 思路
二叉树的层序遍历，根据布尔变量 leftFlag = true 来决定 resLevel 的赋值顺序。
```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        queue<TreeNode*> q;
        vector<vector<int>> res;
        if (root == nullptr) return {};
        q.push(root);
        bool leftFlag = true;
        while (!q.empty()) {
            int sz = q.size(); 
            vector<int> resLevel(sz);
            for (int i = 0; i < sz; ++i) {
                TreeNode *cur = q.front();
                resLevel[leftFlag == true? i: sz - 1 - i] = cur->val; 
                q.pop();
                if (cur->left != nullptr) q.push(cur->left);
                if (cur->right != nullptr) q.push(cur->right);
            }   
            res.push_back(resLevel);
            leftFlag = !leftFlag;
        }  
        return res;
    }
};
```

## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
### 思路
进行后序遍历，看左右子树最深有多深，那么更深的+1对应的就是该结点的最深深度。
```cpp
class Solution {
public:
    int traverse(TreeNode *root) {
        if (root == nullptr) {
            return 0;
        }
        int l = traverse(root->left);
        int r = traverse(root->right);
        if (l > r) {
            return l + 1;
        } else {
            return r + 1;
        }
    }
    int maxDepth(TreeNode* root) {
        return traverse(root);
    }
};
```

## [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
### 思路
首先该点的主要入手点是前序遍历的首结点应该是中序遍历的分割结点。
why？ 见下图，因为前序遍历是首先遍历第一个根节点，即为3，3对应的是中序遍历，遍历完左子树后再遍历到3，最后遍历到右子树，那么根据3就可以找到切割处，就可以把该问题分解为一个子问题。
![image.png](https://note.youdao.com/yws/res/2894/WEBRESOURCE2acf18adf1b8e461d61c32372ecfeaa3)

1. 确定递归函数的参数和返回值： 
- 参数为需要进行重构的子树的前序和中序的边界。
- 返回值为是否满足要求
2. 确定终止条件： 
如果边界不存在那么肯定为空
3. 确定单层递归的逻辑： 
寻找中序遍历的分割点。

递归边界点推导
![image.png](https://note.youdao.com/yws/res/2896/WEBRESOURCE1d2bafe7d7c2350b4cf14c2a5108ae5b)

```cpp
class Solution {
private:
    TreeNode* traverse(const vector<int> &preorder, int preL, int preR,
                       const vector<int> &inorder,  int inL , int inR ) {
                           if (preR < preL) {
                               return nullptr;
                           }
                           TreeNode *root = new TreeNode(preorder[preL]);
                           for (int i = inL; i <= inR; ++i) {
                               if (preorder[preL] == inorder[i]) {
                                    TreeNode *Lroot = traverse(preorder, preL + 1, preL + i - inL,
                                                                inorder,      inL,        i - 1);      
                                    TreeNode *Rroot = traverse(preorder, preL + i - inL + 1, preR,
                                                                inorder,    i + 1,  inR);
                                    root->left = Lroot;
                                    root->right = Rroot;
                               }
                           }
                           return root;
                       }
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        return traverse(preorder, 0, n - 1,
                        inorder,  0, n - 1);
    }
};
```

## [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
### 思路
通过后序找 root节点， 然后根据中序可以进行左子树和右子树的划分。 分治即可。
```cpp
class Solution {
public:
    TreeNode* traverse(vector<int> &inorder, int inL, int inR,
                       vector<int> &postorder, int pL, int pR) {
                            if (inL > inR) {
                               return nullptr;
                            }
                            int valRoot = postorder[pR];
                            int i = inL;
                            for (; i <= inR; ++i) {
                                if (inorder[i] == valRoot) {
                                    break;
                                }
                            }
                            int lenL = i - inL, lenR = inR - i;
                            TreeNode *L = traverse(inorder, inL, i - 1, postorder, pL, pL + lenL - 1);
                            TreeNode *R = traverse(inorder, i + 1, inR, postorder, pL + lenL, pR - 1);
                            TreeNode *root = new TreeNode(valRoot);
                            root->left = L;
                            root->right = R;
                            return root;
                        }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return traverse(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);
    }
};
```
## [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)
### 思路
利用deque的push_front, 改变二叉树的层序遍历变为自底向上即可。
```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> q;
        deque<vector<int>> deq;
        if (root == nullptr) return {};
        q.push(root);
        while (!q.empty()) {
            int sz = q.size();
            vector<int> resLevel;
            for (int i = 0; i < sz; ++i) {
                TreeNode *cur = q.front();
                q.pop();
                resLevel.push_back(cur->val);
                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right);
            }
            deq.push_front(resLevel);
        }
        return vector<vector<int>>(deq.begin(), deq.end());
    }
};
```
## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)
### 思路
一个有序数组对于 BST 来说就是中序遍历结果，根节点在数组中心，数组左侧是左子树元素，右侧是右子树元素。
1. 找中心，分割为两部分，这样左右子树平衡。
2. 分别构建左右子树即可，重复 1 的操作。

```cpp
class Solution {
    TreeNode* buildBST(const vector<int> &nums, int l, int r) {
        if (l > r) {
            return nullptr;
        }
        int m = l + ((r - l) >> 1);
        TreeNode *lRoot = buildBST(nums, l, m - 1);
        TreeNode *rRoot = buildBST(nums, m + 1, r);
        TreeNode *root = new TreeNode(nums[m]);
        root->left = lRoot;
        root->right = rRoot;
        return  root;
    }
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return buildBST(nums, 0, nums.size() - 1);
    }
};
```

## [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)
### 思路
快慢指针找中点 直接变为有序数组的类型即可。
```cpp
class Solution {
    TreeNode* buildBST(ListNode* head, ListNode* tail) {
        if (head == tail) {
            return nullptr;
        }
        ListNode *slow = head, *fast = head;
        while (fast->next != tail && fast->next->next != tail) {
            slow = slow->next;
            fast = fast->next->next;
        }
        TreeNode *L = buildBST(head, slow);
        TreeNode *R = buildBST(slow->next, tail);
        TreeNode *M = new TreeNode(slow->val);
        M->left = L;
        M->right = R;
        return M;
    }
public:
    TreeNode* sortedListToBST(ListNode* head) {
        return buildBST(head, nullptr);
    }
};
```
## 优化方法 感觉和 二叉树的反序列化很类似
观察上述思路，会发现主要时间浪费在搜索中间节点上。其实对链表的重构为二叉树的过程，**本质上**是一个二叉树遍历过程，
因为每次都把数据一分为二的过程，见下图，如果我们可以把所有节点进行遍历的话，其实就可以重构出这个过程隐藏的一个二叉树，就是这样的，分而治之，由于重构过程为二叉树的遍历，那么，按照中序遍历的话，就可以借助链表的顺序弹出进行赋值，因为链表的顺序恰好为该二叉树的中序遍历结果。
![image.png](https://note.youdao.com/yws/res/3526/WEBRESOURCE5f524a9b367808acf3674e7cd64c4583)
```cpp
class Solution {
    TreeNode* buildBST(ListNode* head, ListNode* tail) {
        if (head == tail) {
            return nullptr;
        }
        ListNode *slow = head, *fast = head;
        while (fast->next != tail && fast->next->next != tail) {
            slow = slow->next;
            fast = fast->next->next;
        }
        TreeNode *L = buildBST(head, slow);
        TreeNode *R = buildBST(slow->next, tail);
        TreeNode *M = new TreeNode(slow->val);
        M->left = L;
        M->right = R;
        return M;
    }
public:
    TreeNode* sortedListToBST(ListNode* head) {
        return buildBST(head, nullptr);
    }
};
```
## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)
### 思路
递归函数： 获取结点的最大深度。如果返回 - 1的话， 则说明出现了不平衡的情况，则直接return -1.
```cpp
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(root == nullptr)
        {
            return true;
        }
        return getHeight(root) >= 0;
    }
    //返回-1代表判断失败
    int getHeight(TreeNode* root) 
    {
        if(!root) return 0;
        int l_h = getHeight(root->left);
        int r_h = getHeight(root->right);
        if(r_h == -1 || l_h == -1 || abs(l_h - r_h) > 1)
        {
            return -1;
        }
        return max(l_h, r_h) + 1;
    }
};
```
## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
### 思路
递归搜索即可。注意如下一点。
1. 如果左或是右子树为空的话，需要返回另外一端，因为必须是叶子节点！！！，像下图的3 左端就不应该考虑进来，即使为空。
![image.png](https://note.youdao.com/yws/res/3561/WEBRESOURCEf5408ee9f1f96de267eb9eaf3663f179)

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        int minL = minDepth(root->left);
        int minR = minDepth(root->right);
        if (minL == 0) {
            return minR + 1;
        } 
        if (minR == 0) {
            return minL + 1;
        }
        return min(minL, minR) + 1;
    }
};
```
## [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)
### 思路
输入一个根节点，返回该根节点到叶子节点是否存在一条和为 targetSum 的路径。
最终的判定点是叶子节点!!! 因此需要判断是否左右都为空。
如果叶子节点和 target相等即可。
```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) {            
            return false;
        }
        if (root->left == nullptr && root->right == nullptr && root->val == targetSum) return true;
        
        return hasPathSum(root->left, targetSum - root->val) ||
               hasPathSum(root->right, targetSum - root->val);
    }
};
```
## [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)
### 思路
深搜 + 回溯.
1. 单层递归逻辑：判断是否为叶子节点 同时是否target == 0. 若不是则继续递归搜索。 
```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return;
        }
        path.push_back(root->val);
        if (root->left == root->right && root->val == targetSum) {
            res.push_back(path);
        } else {
            backtracking(root->left, targetSum - root->val);
            backtracking(root->right, targetSum - root->val);
        }
        path.pop_back();
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        backtracking(root, targetSum);
        return res;
    }
};
```

## [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)
### 思路
traverse函数的含义：展开整个列表为右子树单链表。

1. 确定递归函数的参数和返回值： 
- 参数为需要进行展开的root节点。
- 返回值为空
2. 确定终止条件： 
如果为空，则直接返回空
3. 确定单层递归的逻辑： 
**将左子树的节点 接到 root和 right之间即可。**

```cpp
class Solution {
public:
    void traverse(TreeNode *root) {
        if (root == nullptr) {
            return;
        }
        traverse(root->left);
        traverse(root->right);
        TreeNode *cur = root->left;
        if (root->left != nullptr) { // 寻找左子树的尾部节点
            while (cur->right != nullptr) {
                cur = cur->right;
            }
        } else {
            return;
        }
        // 把root和左子树和右子树三部分进行重新拼接
        TreeNode *temp  = root->right;
        root->right = root->left;
        root->left = nullptr;
        cur->right = temp;
    }
    void flatten(TreeNode* root) {
        traverse(root);
    }
};
```
## [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)
### 思路
traverse函数的含义：连接两颗子树。

1. 确定递归函数的参数和返回值： 
- 参数为需要进行连接的两棵子树。
- 返回值为空
2. 确定终止条件： 
如果有一个为空都不需要连接了

3. 确定单层递归的逻辑： 
- **连接相同父节点的子树。**
- **连接，不同父节点的子树。**
```cpp
class Solution {
public:
    /*递归函数的作用：连接两颗子树*/
    void connectTwo(Node *Node1, Node *Node2) {
        if (Node1 == nullptr || Node2 == nullptr) {
            return;
        }
        Node1->next = Node2;
        connectTwo(Node1->left, Node1->right);
        connectTwo(Node2->left, Node2->right);
        connectTwo(Node1->right, Node2->left);
    }
    Node* connect(Node* root) {
        if (!root) return root;
        connectTwo(root->left, root->right);
        return root;
    }
};
```
## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)
### 思路
层序遍历，单层连接即可。
```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> q;
        if (root == nullptr) return nullptr;
        q.push(root);
        while (!q.empty()) {
            int sz = q.size();
            Node *prev = nullptr;
            for (int i = 0; i < sz; ++i) {
                Node *cur = q.front();
                q.pop();
                if (cur->left != nullptr) q.push(cur->left);
                if (cur->right != nullptr) q.push(cur->right);
                if (i == 0) {
                    prev = cur;
                    continue;
                }
                prev->next = cur;
                prev = cur;
            }
        }
        return root;
    }
};
```
## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)
### 思路
路径和的最大值，主要需要解决的是对于每一个节点单侧链的最大值。单侧链（自己定义的）指的就是从该节点到叶子节点的路径。（leetcode有人说这是二叉树的最大直径）。
对于20来说单侧链的最大值就是 20->15， 对于-10来说，单侧链的最大值就是为 -10 20 15.
![image.png](https://note.youdao.com/yws/res/2893/WEBRESOURCE4ee4c168bbc38248e526a500aea86add)

将上面的思路直接进行后续遍历递归即可，算出左子树和右子树的最大直径，但是要注意如果算出来的和为小于0 应该返回0 选择不进行计算即可。  

```cpp
class Solution {
public:
    int maxSum = INT_MIN;
    int maxSumSingleLink(TreeNode *root) {
        if (root == nullptr) {
            return 0;
        }
        int lMax = maxSumSingleLink(root->left);
        int rMax = maxSumSingleLink(root->right);
        int maxPath = max(lMax, rMax) + root->val;
        maxPath = maxPath < 0? 0: maxPath;
        maxSum = max(maxSum, lMax + rMax + root->val);
        return maxPath;
    }
    int maxPathSum(TreeNode* root) {
        maxSumSingleLink(root);
        return maxSum;
    }
};
```

## [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)
### 思路
[113. 路径总和 II] 题类似。 回溯法。很重要的一点是是否进行深搜 是 依据该节点是否为叶子节点.
```cpp
if (root->left == root->right) {
    code:处理路径, 对res求和即可;
} else {
    backtreaing(root->left, ...);
    backtreaing(root->left, ...);
}
```
```cpp
class Solution {
public:
    int res = 0;
    int path = 0;
    void backtracking(TreeNode* root) {
        if (root == nullptr) return;
        path = path * 10 + root->val;
        if (root->left == root->right) {
            res += path; 
        } else {
            backtracking(root->left);
            backtracking(root->right);
        }
        path /= 10; 
    }
    int sumNumbers(TreeNode* root) {
        backtracking(root);
        return res;
    }
};
```
## [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)
### 迭代版本
栈遍历版本： 建议先做中序遍历，后序只是在中序上多了一些操作。

与中序的不同之处在于：

- 中序遍历中，从栈中弹出的节点，其左子树是访问完了，可以直接访问该节点，然后接下来访问右子树。
- 后序遍历中，从栈中弹出的节点，我们只能确定其左子树肯定访问完了，但是无法确定右子树是否访问过。因此，我们在后序遍历中，引入了一个prev来记录历史访问记录。

当访问完一棵子树的时候，我们用prev指向该节点。
这样，在回溯到父节点的时候，我们可以依据prev是指向左子节点，还是右子节点，来判断父节点的访问情况。

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> res;
        if (root == nullptr) return {};
        TreeNode *cur = root, *prve = nullptr;
        while (!st.empty() || cur != nullptr) {
            while (cur != nullptr) { // 把左节点全部压入
                st.push(cur);
                cur = cur->left;
            } 
            /*弹出节点*/
            cur = st.top();
            st.pop();
            /*如果没有右子树，或者右子树访问完了，也就是上一个访问的节点是右子节点时说明可以访问当前节点*/
            if (cur->right == nullptr || prve == cur->right) {
                res.push_back(cur->val);
                prve = cur;
                cur = nullptr; // 关键点，访问完中间节点后需要把它值为nullptr， 否则会陷入死循环。
            } else{
                /*如果右边还有子节点的话，那么把中间节点再次压入，开始遍历右子树*/
                st.push(cur);
                cur = cur->right;
            }
        }
        return res;
    }
};
```
利用reverse
---
```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```

## [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)
### 思路
利用stack来模拟中序遍历。
需要cur指针来辅助当前的节点位置。
就是中序遍历，只不过呢，一次遍历一次而已。

```cpp
class BSTIterator {
public:
    TreeNode *cur;
    stack<TreeNode*> st;
    BSTIterator(TreeNode* root): cur(root) {

    }
    
    int next() {
        while (cur) { // 从左一撸到底
            st.push(cur);
            cur = cur->left;
        }
        cur = st.top();
        st.pop();
        int rtv = cur->val;
        cur = cur->right;
        return rtv;
    }
    
    bool hasNext() {
        return !st.empty() || cur;
    }
};

```

## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)
### BFS思路
1、用 BFS 层序遍历算法，每一层的最后一个节点就是二叉树的右侧视图。我们可以把 BFS 反过来，从右往左遍历每一行，进一步提升效率。

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> q;
        if (root == nullptr) return {};
        q.push(root);
        vector<int> res;
        while (!q.empty()) {
            int sz = q.size();
            TreeNode *cur = nullptr;
            for (int i = 0; i < sz; ++i) {
                cur = q.front();
                q.pop();
                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right); 
            }
            if (cur) res.push_back(cur->val);
        }
        return res;
    }
};
```

### DFS思路
2、用 DFS 递归遍历算法，同样需要反过来，先递归 root.right 再递归 root.left，同时用 res 记录每一层的最右侧节点作为右侧视图。
```cpp
class Solution {
public:
    int depth = 0;
    vector<int> res;
    void dfs(TreeNode *root) {
        if (root == nullptr) return;
        depth += 1;
        if (res.size() < depth) {
            res.push_back(root->val);
        }
        dfs(root->right);
        dfs(root->left);
        depth--;
    }
    vector<int> rightSideView(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

## [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)
### 思路
labuladong思路：
![image.png](https://note.youdao.com/yws/res/3706/WEBRESOURCE1768dd3417cfdf2a85b00cd90efe27ce)
要点：
1. 判断完全二叉树的方法： 求左右边的深度是否相等
2. num = 2 ^ depth - 1.
3. 递归+剪纸即可。
```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        int L = 0, R = 0;
        TreeNode *curL = root, *curR = root;
        while (curL) {
            L++;
            curL = curL->left;
        }
        while (curR) {
            R++;
            curR = curR->right;
        }
        if (L == R) {
            return pow(2, L) - 1;
        }
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};
```


## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)
### 思路
假设该递归函数可以进行翻转，则先交换左右子树。
在对左右子树分别进行翻转即可。

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

## [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)
### 思路
二叉搜索树的中序遍历则为升序序列，根据这个原则，记录每次遍历的结果的cnt值，当cnt值达到 k ，返回即可，退出函数。

```cpp
class Solution {
public:
    int cnt = 0;
    int res = 0;
	int kthSmallest(TreeNode* root, int k) {
        traverse(root, k);
        return res;
	}
	void traverse(TreeNode* root, int k) {
        if (root == nullptr) {
            return;
        }
        traverse(root->left, k);
        cnt++;
        if (k == cnt) {
            res = root->val;
            return;
        }
        traverse(root->right, k);
	}
};
```
## [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
### 思路
BST公共祖先的特点是： root->val <= p->val && root->val >= q->val;
通过深度搜索，第一次搜到的数则是满足要求的数。
![image.png](https://note.youdao.com/yws/res/3721/WEBRESOURCEf8b84bfa00ac34023a7cf7d800312575)
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root->val > p->val && root->val > q->val) {
            return lowestCommonAncestor(root->left, p, q);
        }
        if (root->val < p->val && root->val < q->val) {
            return lowestCommonAncestor(root->right, p, q);
        }
        return root;
    }
};
```


## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
### 思路
定义递归函数的含义: 
1. 查找root中是否有p 或是 q，有的话则直接返回 p、q 否则为nullptr.
2. 如果为最近的公共祖先答案则返回答案即可。
由于是自底向上，那么可以联想到用后序遍历进行从底向上的回溯。
![image.png](https://note.youdao.com/yws/res/3731/WEBRESOURCEf0f02776db9414f63395def96a14e6ff)
单层的递归逻辑：
![image.png](https://note.youdao.com/yws/res/3732/WEBRESOURCE97d18d45029777a3afef24912e831204)
```cpp
class Solution {
public:
    /*递归函数的定义，查找root中是否有p 或是 q，有的话则直接返回 p、q 否则为空*/
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) return root;
        /*自底向上，后续遍历进行回溯*/
        TreeNode *resL = lowestCommonAncestor(root->left, p, q);
        TreeNode *resR = lowestCommonAncestor(root->right, p, q);
        /*case1：确定是否为祖先节点 */
        if (resL == p && resR == q || resL == q && resR == p) {
            return root;
        } 
        /*case2：两边都无p、q 及结果 */
        if (resL == nullptr && resR == nullptr) return nullptr;
        /*case3：其中一边为p、q 结果 或是 另一边为 p、q 结果，如图 7、10节点为返回结果 */
        return resL != nullptr? resL: resR;
    }
};
```
## [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)
### 思路
前序遍历进行序列化：
![image.png](https://note.youdao.com/yws/res/3421/WEBRESOURCE714f55a2b89606f75cea37fc64054bea)

按照前序遍历进行反序列化即可：
假设该递归函数可以反序列化， 则对于root结点来说，则需要将left和right子树进行构造即可，由于每次队列都会弹出已经遍历过的元素，因此直接输入队列即可。
终止条件: 遇到 # 则可以返回nullptr

```cpp
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if (root == nullptr) {
            return "#";
        }
        /*前序遍历*/
        string Lstr = serialize(root->left);
        string Rstr = serialize(root->right);
        return to_string(root->val) + "," + Lstr + "," + Rstr;
    }

    TreeNode *traverse(queue<string> &q) {
        string s = q.front();
        q.pop();
        TreeNode *root = nullptr;
        if (s == "#") {
            return nullptr;
        } else {
            root = new TreeNode(stoi(s));
        }
        TreeNode *L = traverse(q);
        TreeNode *R = traverse(q);
        root->left = L;
        root->right = R;
        return root;
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(const string &data) {
        // cout << data << endl;
        string s;
        queue<string> q;
        for (auto &ch: data) {
            if (ch != ',') {
                s += ch;
            } else {
                q.push(s);
                s.clear();
            }
        }
        q.push(s);
        return traverse(q);
    }
};
```
## [341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)
### dfs递归思路
递归的生成vec数组。
```cpp
class NestedIterator {
private:
    vector<int> vec;
    vector<int>::iterator cur;
    void dfs(vector<NestedInteger> &nestedList) {
        for (auto &lst: nestedList) {
            if (lst.isInteger()) {
                vec.push_back(lst.getInteger());
            } else {
                dfs(lst.getList());
            }
        }
    }
public:
    NestedIterator(vector<NestedInteger> &nestedList) {
        dfs(nestedList);
        cur = vec.begin();
    }
    
    int next() {
        return *(cur++);
    }
    
    bool hasNext() {
        return cur != vec.end();
    }
};
```
## 思路 利用栈迭代的思路
栈去保存 vector的 左右边界迭代器。
1. pair<iter, iter> &p = stk.top(); // 需要修改stk中的值，所以引用
2. vector<NestedInteger> &vec = (p.first++)->getList(); // 不做copy，防止vec离开作用域 其中的变量被析构。
```cpp
class NestedIterator {
public:
    typedef vector<NestedInteger>::iterator iter;
    stack<pair<iter, iter>> stk;
    NestedIterator(vector<NestedInteger> &nestedList) {
        stk.emplace(nestedList.begin(), nestedList.end());
    }
    
    int next() {
        return stk.top().first++->getInteger();
    }
    
    bool hasNext() {
        while (!stk.empty()) {
            pair<iter, iter> &p = stk.top(); // 需要修改stk中的值，所以引用
            if (p.first == p.second) {
                stk.pop();
                continue;
            }
            if (!p.first->isInteger()) {
                // cout << 1 << endl;
                vector<NestedInteger> &vec = (p.first++)->getList();
                // cout << vec.begin()->getInteger() << endl;
                stk.emplace(vec.begin(), vec.end());
                //p.first++;
                continue;
            }
            return true;
        }
        return false;
    }
};
```

## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)
### 思路
题意如下，找圈出的部分。
![image.png](https://note.youdao.com/yws/res/3256/WEBRESOURCE38ceada88729369f1ffdb4ea87cf5b86)

记录前缀和，即深度搜索时整条链的所有前缀和的个数，即对应下图的四个红圈的和，刚好是一条单链。
![image.png](https://note.youdao.com/yws/res/3260/WEBRESOURCE5ed9f0ca538377c92203ae7e30bcb5be)
判断 res += hashTable[cur - targetSum]的和的个数， 即代表如下图，cur - targetSum如果是某个前缀和的话，那么说明就有一条链满足条件，因此 += 即可。
![image.png](https://note.youdao.com/yws/res/3264/WEBRESOURCEf9b050851d7e090bc04d59b77aa12d8e)
```cpp
class Solution {
public:
    int res = 0;
    unordered_map<long long, int> hashTable; // 前缀和出现的次数
    void traverse(TreeNode* root, long long cur, int targetSum) {
        if (root == nullptr) {
            return;
        }
        cur += root->val;
        if (hashTable[cur - targetSum] > 0) {
            res += hashTable[cur - targetSum];
        }
        hashTable[cur]++;
        traverse(root->left, cur, targetSum);
        traverse(root->right, cur, targetSum);
        hashTable[cur]--;
        return;
    }
    int pathSum(TreeNode* root, int targetSum) {
        hashTable[0] = 1;
        traverse(root, 0, targetSum);
        return res;
    }
};
```

## [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)
### 思路
删除和添加均需要返回结点才行， 将重新删除的得到的新子根节点拼接到父根节点上，避免老子根节点被删除。
根据二叉搜索树的二分性质，先搜到该点，然后根据如下三种情况进行删除。
![image.png](https://note.youdao.com/yws/res/3438/WEBRESOURCE3355fe4982547de3d074577ab4c524fb)
![image.png](https://note.youdao.com/yws/res/3439/WEBRESOURCE4101d55aa527161c76df3ec1a1d43bea)
![image.png](https://note.youdao.com/yws/res/3440/WEBRESOURCEc40c0e86ad5ad10df6f1760004ee1872)
```cpp
class Solution {
public:
    TreeNode* getMin(TreeNode *root) {
        while (root->left != nullptr) {
            root = root->left;
        }
        return root;
    }
    TreeNode* traverse(TreeNode *root, int key) {
        if (root == nullptr) {
            return nullptr;
        }
        if (root->val == key) {
            //包含在case 2中
            // if (root->left == nullptr && root->right == nullptr) {
            //     return nullptr;   
            // }
            if (root->left == nullptr) return root->right;
            if (root->right == nullptr) return root->left;
            TreeNode *minNode = getMin(root->right);
            root->right = traverse(root->right, minNode->val);
            minNode->left = root->left;
            minNode->right = root->right;
            root = minNode;
        } else if (root->val > key) {
            root->left = deleteNode(root->left, key);
        } else {
            root->right = deleteNode(root->right, key);
        }
        return root;
    }
    TreeNode* deleteNode(TreeNode* root, int key) {
        return traverse(root, key);
    }
};
```

## [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)
### 思路
根据二分性质就行搜索即可
```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == nullptr) {
            return nullptr;
        }
        if (root->val == val) {
            return root;
        } else if (root->val > val) {
            return searchBST(root->left, val);
        } else {
            return searchBST(root->right, val);
        }
        return nullptr;
    }
};
```
## [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)
### 思路
删除和添加均需要返回结点才行， 将新添加的子根节点拼接到父根节点上。
```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == nullptr) {
            return new TreeNode(val);
        }
        if (root->val > val) {
            root->left = insertIntoBST(root->left, val);
        } 
        if (root->val < val) {
            root->right = insertIntoBST(root->right, val);
        }
        return root;
    }
};
```
## [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)
### 思路
BFS 记录每层出现的第一次，即是左下角。

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> q;
        if (root == nullptr) return 0;
        q.push(root);
        int res = 0;
        while (!q.empty()) {
            int sz = q.size();
            for (int i = 0; i < sz; ++i) {
                TreeNode *cur = q.front();
                q.pop();
                if (i == 0) res = cur->val;
                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right);
            }
        }
        return res;
    }
};
```
## DFS
深度搜索+回溯， 维护当前搜索的深度depth和最大深度 maxDepth即可。res保留depth最大的时候的值。同时优先搜左侧的即可。
```cpp
class Solution {
public:
    int depth = 0; // 记录当前深度
    int maxDepth = 0; // 记录最大深度
    int res = 0; // 结果
    void dfs(TreeNode* root) {
        if (root == nullptr) return;
        depth++;
        if (depth > maxDepth) {
            res = root->val;
            maxDepth = depth;
        }
        dfs(root->left);
        dfs(root->right);
        depth--;
    }
    int findBottomLeftValue(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

## [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)
### 思路
题意：把树中大于等于结点的值求和赋给该节点。
利用中序遍历改(先右再左)，可以按照从大到小的顺序遍历，那么每次遍历对 sum 进行增加，则可以获得大于等于该值的总和。
```cpp
class Solution {
public:
    int sum = 0;
    TreeNode* convertBST(TreeNode* root) {
        if (root != nullptr) {
            convertBST(root->right);
            sum += root->val;
            root->val = sum;
            convertBST(root->left);
        }
        return root;
    }
};
```

## [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)
### 思路
利用递归后序遍历，对每个结点的最长子链进行搜索，最长子链的定义就是该节点到叶子节点的最长距离。
比如说 1 为结点的话， 1 2 4为最长子链。
那么搜索完 1 左右的最长子链就可以获得以 1 为结点的最长路径为 4-2-**1**-3, 递归更新即可。
![image.png](https://note.youdao.com/yws/res/3300/WEBRESOURCEd2def333f87d56f68db7ad65d01bbb0d)

```cpp
class Solution {
public:
    int maxD = 0;
    int traverse(TreeNode *root) { // 找最长链
        if (root == nullptr) {
            return 0;
        }
        int L = 0, R = 0;
        L = traverse(root->left);
        R = traverse(root->right);
        maxD = max(L + R, maxD);
        return max(L, R) + 1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        traverse(root);
        return maxD;
    }
};
```
## [606. 根据二叉树创建字符串](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)
### 思路
后序遍历即可， 但是要注意一点，括号是否添加的问题。分如下四类情况，主要是右子树不为空，左子树为空的话，左子树要加括号对应下图第二种情况。但是左子树不为空，右子树为空的话，则右子树不需要括号。
![image.png](https://note.youdao.com/yws/res/3538/WEBRESOURCE8c3b776fe0f87d576c08da383c8daa28)

```cpp
class Solution {
public:
    string tree2str(TreeNode* root) {
        if (root == nullptr) {
            return {};
        }
        string L = tree2str(root->left);
        string R = tree2str(root->right);
        string M = to_string(root->val);
        if (root->right != nullptr) {
            return M + "(" + L + ")"+ "(" + R + ")";
        } 
        if (root->left != nullptr) {
            return M + "(" + L + ")";
        }
        return M;
    }
};
```

## [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)
### 思路
假想该函数可以合并二叉树，那么首先把左右子树合并了，后序遍历。

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == nullptr) {
            return t2;
        }
        if (t2 == nullptr) {
            return t1;
        }
        auto merged = new TreeNode(t1->val + t2->val);
        merged->left = mergeTrees(t1->left, t2->left);
        merged->right = mergeTrees(t1->right, t2->right);
        return merged;
    }
};
```
## [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)
### 思路
同二叉树的序列化和反序列，利用string这个数据结构作为每个结点的序列化结果。
递归函数： 获得root结点的前序遍历的序列化结果。
单层逻辑： 将得到的序列化结果存入哈希表中， 哈希表代表序列的出现次数，如果该次数是从1变为2的话，则说明有重复的一次，则push_back进入结果向量中。
```cpp
class Solution {
public:
    unordered_map<string, int> hashMap;
    vector<TreeNode*> res;
    string traverse(TreeNode *root) {
        if (root == nullptr) {
            return "#";
        }
        string strL = traverse(root->left);
        string strR = traverse(root->right);
        string strM = to_string(root->val) + "," + strL + "," + strR;
        if (++hashMap[strM] == 2) {
            res.push_back(root);
        }
        return strM;
    }
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        traverse(root);
        return res;
    }
};
```
## [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)
### 思路
前序遍历：假设递归函数traverse可以构造[l, r]范围的最大二叉树。
1. 找最大值

```cpp
class Solution {
public:
    TreeNode *traverse(const vector<int> &nums, int l, int r) {
        if (l > r) {
            return nullptr;
        }
        auto itMax = max_element(nums.begin() + l, nums.begin() + r + 1); // 找最大的序号
        TreeNode *root = new TreeNode(*itMax);
        int m = itMax - nums.begin();
        TreeNode *left = traverse(nums, l, m - 1);
        TreeNode *right = traverse(nums, m + 1, r);
        root->left = left;
        root->right = right;
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traverse(nums, 0, nums.size() - 1);
    }
};
```

## [1373. 二叉搜索子树的最大键值和](https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/)
### 思路
简单说就是要知道以下具体信息：

1、左右子树是否是 BST。

2、左子树的最大值和右子树的最小值。

3、左右子树的节点值之和。

注意以下：
1. 递归终止条件的返回值，必须满足要求最大值为INT_MIN, 最小值为 INT_MAX.
2. 更新最大值和最小值时，应该特殊考虑是否为左右子树为null的情况，避免把INT_MAX INT_MIN传递上去。


```cpp
class Solution {
public:
    int res = 0;
    /*返回值结果：[0]: 是否有效 [1]:最大值 [2]:最小值 [3]:和*/
    vector<int> traverse(TreeNode *root) {
        if (root == nullptr) {
            return {1, INT_MIN, INT_MAX, 0};
        }
        vector<int> resM(4);
        vector<int> resL = traverse(root->left);
        vector<int> resR = traverse(root->right);
        if (resL[0] == 1 && resR[0] == 1 && resL[1] < root->val && resR[2] > root->val) {
            resM[0] = 1;
            resM[1] = root->right == nullptr? root->val: resR[1];//max(resR[1], root->val);
            resM[2] = root->left == nullptr? root->val: resL[2];//min(resL[2], root->val);
            resM[3] = root->val + resL[3] + resR[3];
            res = max(res, resM[3]);
        }
        // cout << "root " << root->val << " " << resM[0] << " " << resM[1]<< " " << resM[2] << " " << resM[3] << endl;
        return resM;
    }
    int maxSumBST(TreeNode* root) {
        traverse(root);
        return res;
    }
};
```