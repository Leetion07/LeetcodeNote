[TOC]

## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)
### **思路**
回文串先判断两边的字符是否相等，如果相等根据中间的部分是否为回文串可以递推出来，但是需要特殊处理长度为2和长度为3的字符串。

1. dp数组的含义：s[i, j]是否为回文串
2. 递推公式：s[i] == s[j] -> s[i, j] = s[i + 1, j - 1] L > 3; s[i, j] = 1 L <=3
          s[i] != s[j] -> s[i, j] = 0
3. dp数组如何初始化: 对角线即[i, i] = 1
4. 确定遍历顺序: 由子串长度从2开始到size - 1进行遍历

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int sz = s.size();
        int maxLen = 0;
        int begin = 0;
        vector<vector<int>> dp(sz, vector<int>(sz));
        for (int i = sz - 1; i >= 0; i--) {
            for (int j = i; j < sz; j++) {
                if (s[i] != s[j]) {
                    dp[i][j] = 0;
                } else {
                    if (j - i <= 2) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j]) {
                    if (maxLen < j - i + 1) {
                        maxLen = j - i + 1;
                        begin = i;
                    }
                }
            }
        }
        return s.substr(begin, maxLen);
    }
};
```
## [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)
### **思路**
**关键点**
```
字母 + 星号的组合在匹配的过程中，本质上只会有两种情况：

匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；

不匹配字符，将该组合扔掉，不再进行匹配。
```

题目解释：对于p[j]如果是.的话，可以任意替换
如果是*，a*可以代表 空串 或是 aaaaa。
那么遇到 a星 如何处理。一个比较简单的方案就是要么直接当作空串使用掉它，则j需要向前跳两格p[j-2]和s[i]，要么就直接把a*当作一个整体和s[i]进行匹配，则j向前跳一个，看p[j-1]和s[i]，因为是双层for循环，下一层for循环p的时候还会用到遍历到该星号。
因此dp数组定义为s的前i个字符和p的前j个字符是否匹配。
![image.png](https://note.youdao.com/yws/res/2779/WEBRESOURCE9831b040be49ec20e6b91f0e76c97861)
注意s的for可以从0开始，因为“”和“a*”是可以匹配的，这个在后续的递推有用。
最关键的递推！！！
看这种情况:
x x s[i-1] a
x x s[j-2] ==a *==
有这种可能 此处的 a 星 已经在 s[i-1]用过一次了！这是最关键的一点，多次使用的a 星。
如果仅仅考虑s[i-1]和s[j-2]相等的情况，其实和直接舍弃是一样的，会少考虑。这里的a 星也可以和s[i-1]对齐，在s[i-1]被使用。比如说
s：a a a a a
p：a * 
假如*和s[3]对上了，那么可以找 a a和 a *的匹配，这就是a *可以重复使用的情况。
dp[i][j] |= dp[i][j - 2]; // case1: 舍弃该a*，直接空退两个
if (matches(i, j - 1)) {  //s[i - 1]和此处的a 星匹配上了，
    dp[i][j] |= dp[i - 1][j];
}

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();

        auto matches = [&](int i, int j) {
            if (i == 0) {
                return false;
            }
            if (p[j - 1] == '.') {
                return true;
            }
            return s[i - 1] == p[j - 1];
        };

        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        dp[0][0] = true;
        for (int i = 0; i <= m; ++i) { // s为空串时，也是可以匹配的。比如说s = "" p = "a*"
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    dp[i][j] |= dp[i][j - 2];//若为1则为1
                    if (matches(i, j - 1)) {
                        dp[i][j] |= dp[i - 1][j];//取dp[i - 1]和
                    }
                }
                else {
                    if (matches(i, j)) {
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                }
            }
        }
        return dp[m][n];
    }
};

```
## [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)
### **思路**
首先题目是找子串说明是**连续**的。
四部曲：

**dp[i]数组**
下标 `i` 字符结尾的最长有效括号的长度
**转移方程**
当遍历到第i个数，此时索引一个为 i - 1，如果为'('则直接为不合格。
如果为 ')' 进行讨论， 如果 i - 2 为 '(' 说明合格，至少最后两个合格。
如果 i - 2为 ')'   即这种情况  ......))。
此时的话，根据dp[i - 2] 可以看出 i - 2之前的最长字串的长度，根据这个去找左边界。

**初始化**
可以把子串最长长度长度设置为0。
因为0长度肯定为0， 1长度也必然为0.

**遍历顺序**
从左到右，很容易看出来


```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        int maxans = 0, n = s.length();
        vector<int> dp(n, 0);
        for (int i = 1; i < n; i++) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = max(maxans, dp[i]);
            }
        }
        return maxans;
    }
};

```

## [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
### **思路**
遍历每一列，通过每一列的左最大值，右最大值，确定可以盛水的最大高度，利用 min(maxLeft[i], maxRight[i]) - height[i]可以计算得到。
怎么想到动态规划的呢？
1. 从暴力解法的角度考虑，比较出现了多次重复的情况。
2. i+1的左侧最大值和i的左侧最大值有关
主要需要用到动态规划的是: 计算maxLeft和maxRight数组。
maxLeft数组：左侧包含自己的最大值.
maxRight数组：右侧包含自己的最大值.
递推：
maxLeft[i] = max(maxLeft[i-1], height[i])左到右
maxLeft[i] = max(maxLeft[i-1], height[i])右到左
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int sum = 0;
        vector<int> maxLeft(height.size());
        vector<int> maxRight(height.size());
        maxLeft[0] = height[0];
        maxRight.back() = height.back();
        for (int i = 1; i < height.size(); i++) {
            maxLeft[i] = max(maxLeft[i - 1], height[i]);
        }
        for (int i = height.size() - 2; i >= 0; i--) {
            maxRight[i] = max(maxRight[i + 1], height[i]);
        }

        for (int i = 1; i < height.size() - 1; i++) {
            sum += min(maxLeft[i], maxRight[i]) - height[i];
        }
        return sum;
    }
};
```
## [53.最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
### **思路**
四部曲：

**dp[i]数组**
dp[i]：包括下标i之前的最大连续子序列和为dp[i]。

**转移方程**
* dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和
* nums[i]，即：从头开始计算当前连续子序列和
一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]);

**初始化**
从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。

dp[0]应该是多少呢?

根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] = nums[0]。

**遍历顺序**
递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        /*以 i 结尾的最长子数组的和*/
        vector<int> dp(n);
        dp[0] = nums[0];
        int res = dp[0];
        for (int i = 1; i < n; ++i) {
            dp[i] = max(nums[i], dp[i - 1] + nums[i]);
            res = max(res, dp[i]);
        }
        return res;
    }
};
```
## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)
### **思路**
记录在每个点的选择只有向右或者向下

四部曲：

**dp[i][j]数组**
(0,0) -> (i,j)有多少不同种的走法。

**转移方程**
只能从上或者从左转移过来，则dp[i][j]=dp[i][j-1]+dp[i-1][j]

**初始化**
由于第一行，第一列为边界，可以直接设为 1

**遍历顺序**
显然是从左上到右下  


```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)
### **思路**
**dp[i][j]数组**
(0,0) -> (i,j)有多少不同种的走法。

**转移方程**
只能从上或者从左转移过来，则dp[i][j]=dp[i][j-1]+dp[i-1][j]

**初始化**
由于第一行，第一列为边界，可以直接设为`1`.
但是如果遇到 障碍物 后续应该全为 0， 因为如果第一行或是第一列有障碍物的话，后续都无法到达。
`i < m && obstacleGrid[i][0] == 0`.

**遍历顺序**
显然是从左上到右下  

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```
## [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)
### **思路**
**很重要的一点是只能像右或者向下运动**

**dp[i][j]数组的含义**
从起点到i，j的最小cost

**状态转移方程**
从上或者从左转移作选择

**dp数组初始化**
先初始化第一列，因为方向唯一。
第一行方向也唯一。

**遍历顺序**
从左上到右下进行遍历。

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n));
        dp[0][0] = grid[0][0];
        for (int i = 1; i < n; i++) {
            dp[0][i] = dp[0][i - 1] + grid[0][i];   
        }
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];   
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp.back().back();
    }
};
```
## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
### **思路**

**dp[i]**
爬到第i层楼梯，有dp[i]种方法

**状态转移方程**
从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。

首先是dp[i - 1]，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。

还有就是dp[i - 2]，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！

所以dp[i] = dp[i - 1] + dp[i - 2] 。

**dp数组初始化**
不考虑dp[0]如果初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。

**遍历顺序**
从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的
![image.png](https://note.youdao.com/yws/res/2787/WEBRESOURCE01317caa92f5ee21d3486147e93fd2a7)

## [583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)
### **思路**
编辑距离的简单版本，把所有的改变转换为word1的改变，这是关键点。
仅仅看状态转移的方法即可，具体的动规四部曲都在注释下。
word1[i-1] == word2[j-1]
![image.png](https://note.youdao.com/yws/res/4080/WEBRESOURCE8c50a505dbcb295650395daa2666bd90)
word1[i-1] != word2[j-1]
删除word1
![image.png](https://note.youdao.com/yws/res/4083/WEBRESOURCE98b4036a2dd08dac3d4107ab82536cc3)
增加word1
![image.png](https://note.youdao.com/yws/res/4085/WEBRESOURCE3625ae0c5e9bec6c3578d0279b38d0ae)
```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        /*word2 删相当于word1 增. 那么仅仅考虑 word1 转换为 word2 增删的最小步数即可*/
        int m = word1.size(), n = word2.size();
        /*dp[i][j]表示的是word1[0~i-1]通过增删转换为word2[0~j-1]的最小步数*/
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        /*初始化word1为空串时，转换为word2所需要的步数，等于word2的长度*/
        for (int i = 1; i <= m; ++i) dp[i][0] = i;
        /*初始化word2为空串时，word1转换为word2所需要的步数，等于word1的长度*/
        for (int j = 1; j <= n; ++j) dp[0][j] = j;
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                /*相同的话，结果为word1和word2分别前进一位*/
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                /*不相同的话，有两种选择，增或删，增的话就看word1保持不变
                结果为dp[i][j - 1], 删的话，word2保持不变结果为dp[i - 1][j]*/
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1;
                }
            }
        }
        return dp[m][n];
    }
};
```
## [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)
### **思路**
从dp来看的话 实际上就是1143. 最长公共子序列的问题.
cpp答案一摸一样
```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int m = s.size(), n = t.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        // cout << dp[m][n] << "\n";
        return dp[m][n] == s.size();
    }
};
```
## [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)
### **思路**

![image.png](https://note.youdao.com/yws/res/2775/WEBRESOURCE14d4d96509f127ea9ae42f48d628a1f0)

**dp[i][j]数组的含义（m+1 n+1）**
以i-1，j-1结尾的子串的最小编辑距离

**状态转移方程**
如果结尾相同，则直接看以i-2和j-2结尾的子串的最小编辑距离即可
如果结尾不相同，三种选择 增 删 换。以word1: hor子串转换为word2: ro子串为例
增加一个字符：相当于看以i-1,j-2的最小编辑距离加1, horo 和ro，则看hor和r即可
删除一个字符：相当于看以i-2,j-1的最小编辑距离加1，ho和ro，看ho和ro即可
替换一个字符：相当于看以i-2,j-2的最小编辑距离加1，hoo和ro，则看ho和r即可
**上述情况只讨论了 hor 转换为 ro 的情况，若是 ro 也改变呢？**
若是word2: ro增加，ror的话， 则看ro 和 ho即可， 和 word1 删除字符相同。
若是word2：ro删除，r的话， 则看 r 和 hor， 和word1增加同
替换肯定也一样，则仅考虑word1转换为word2即可。

**dp数组初始化**
空串转空串的话 为0次编辑
注意一点，horse转换为空串的话 ""， 肯定是对应的 1 2 3 4 5次，每次减少一个肯定最少。
空串 "" 转换为ros对应的是 1 2 3 每次肯定是添加一个最少 显然易见
因此先将第一行和第一列初始化，

**遍历顺序**
从左上到右下进行遍历。
![image.png](https://note.youdao.com/yws/res/2789/WEBRESOURCE385a4881711c29cafd4641f0dcd2f7fe)

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= n; i++) {
            dp[0][i] = i;
        }
        for (int j = 1; j <= m; j++) {
            dp[j][0] = j;
        }
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
            }
        }
        // for (int i = 0; i <= m; i++) {
        //     for (int j = 0; j <= n; j++) {
        //         cout << dp[i][j] << " ";
        //     }
        //     cout << endl;
        // }
        return dp[m][n];
    }
};
```

## [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
### **思路**
其实就是对于每一个高度，进行画最大的矩形，比较每一个高度哪一个要大一点。
比如说2 1 5 6 2 3
2高度：最高就是2
1高度：最高就是1 1 1 1 1 1
...
5高度：5 5
入手点是：要找到每一列对应的左边第一个较小的数的索引以及每一列右边第一个较小数的索引
![image.png](https://note.youdao.com/yws/res/2777/WEBRESOURCE5f05fc95e919302027bb336000ed226f)

**动态规划**
索引 i 向左搜索的过程: 先判断hegiht[i - 1] 是否小于 height[i]，小于则直接加入， 如果大于的话， 就跳转到i-1对应的首个最小值，firstMinLeft[i - 1]保存，直到到达左边界或者找到满意的为止。
索引 i 向左搜索的过程: 先判断hegiht[i + 1] 是否小于 height[i]，小于则直接加入， 如果大于的话， 就跳转到i + 1对应的首个最小值，firstMinLeft[i + 1]，直到到达右边界或者找到满意的为止。
```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int sum = 0;
        int sz = heights.size();
        vector<int> firstMinLeft(sz);
        firstMinLeft[0] = -1;
        vector<int> firstMinRight(sz);
        firstMinRight.back() = sz;
        for (int i = 1; i < sz; i++) {
            int tmp = i - 1;
            while (tmp != -1 && heights[tmp] >= heights[i]) {
                tmp = firstMinLeft[tmp];
            }
            firstMinLeft[i] = tmp;
        }
        for (int i = sz - 1; i >= 0; i--) {
            int tmp = i + 1;
            while (tmp != sz && heights[tmp] >= heights[i]) {
                tmp = firstMinRight[tmp];
            }
            firstMinRight[i] = tmp;
        }

        for (int i = 0; i < sz; i++) {
            int h = heights[i];
            int w = firstMinRight[i] - firstMinLeft[i] - 1;
            sum = max(sum, h * w);
        }
        return sum;
    }
};
```

## [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)
### **思路**
先将整个矩形在横向上拍扁
求一个最大索引矩阵，表示的是从该点的左侧最多有多长的连续1，然后转换为[84. 柱状图中最大的矩形]，用该题的方法求解最大矩阵的长度。
只需要求解被拍扁的每一列的长度即可
```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> MaxIndex(m, vector<int>(n));
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (matrix[i][j] == '1') {
                    MaxIndex[i][j] = j > 0? MaxIndex[i][j - 1] + 1: 1;
                }
                // cout << MaxIndex[i][j] << " ";
            }
            // cout << endl;
        }
        int sum = 0;
        for (int i = 0; i < n; ++i) {
            vector<int> Lmin(m), Rmin(m);
            Lmin[0] = -1;
            Rmin[m - 1] = m;
            for (int j = 1; j < m; ++j) {
                int temp = j - 1;
                while (temp >= 0 && MaxIndex[j][i] <= MaxIndex[temp][i]) {
                    temp = Lmin[temp];
                }
                Lmin[j] = temp;
            }
            for (int j = m - 2; j >= 0; --j) {
                int temp = j + 1;
                while (temp < m && MaxIndex[j][i] <= MaxIndex[temp][i]) {
                    temp = Rmin[temp];
                }
                Rmin[j] = temp;                
            }
            for (int j = 0; j < m; ++j) {
                int h = MaxIndex[j][i];
                int w = Rmin[j] - Lmin[j] - 1;
                // cout << Lmin[j] << " " << Rmin[j] << " " << MaxIndex[j][i] << endl;
                sum = max(sum, h * w);
            }
        }
        return sum;
    }
    
};
```
## [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)
### **思路**
求 t 在 s 中出现的次数.

**dp[i][j]**
dp[i][j]：以i-1为结尾的s的**子序列**中出现以j-1为结尾的t的个数为dp[i][j]。
==s[0 ~ i-1]的子序列中会出现 多少t[0 ~ j-1].==

**状态转移**
若是s[i-1] == t[j-1], 则可以固定最后一位，即s[0 ~ i - 2] 中有 多个少个t[0 ~ j - 2] => dp[i - 1][j - 1] 肯定算一部分. 还有一部分就是 dp[i - 1][j], 之前已经匹配的部分不能忘掉.
![image.png](https://note.youdao.com/yws/res/4061/WEBRESOURCE83fe59af82eb78e43e251c0db9d0ab91)
若是s[i-1] != t[j-1]，则只有dp[i - 1][j].
举个例子
s: rabb t: rab
已知dp[3][3] = 1, dp[2][2] = 1, dp[1][1] = 1. dp[3][2] = 1.
求dp[4][3]时, 相同的话，dp[4][3] = dp[3][2] + dp[3][3] = 2.

**初始化**
观察上图的转移结果可知，需要边界的值进行初始化. 
左边界对应的是空串t， 显然逻辑上来说应该有 1 种方法， 那就是 s 啥也不选.
上边界对应的是空串s， 除了 t 为空， 那么 方法为 0.
则左边全为 1， 上为 0.
![image.png](https://note.youdao.com/yws/res/4067/WEBRESOURCE483f9118ea36b3b8ca78708bc61a3e31)

**遍历顺序**
从上到下

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int m = s.size(), n = t.size();
        vector<vector<uint64_t>> dp(m + 1, vector<uint64_t>(n + 1));
        for (int i = 0; i <= m; ++i) {
            dp[i][0] = 1;
        }
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[m][n];
    }
};
```

## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
### **思路**
**本文只有一次交易**

**dp[i][j]含义**
dp[i][0] 表示第i天持有股票所得最多现金 
dp[i][1] 表示第i天不持有股票所得最多现金

**状态转移:**
1. 如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来
- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]
- 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]那么dp[i][0]应该选所得现金最大的，所以dp[i][0] = max(dp[i - 1][0], -prices[i]); ps：==第i天买入的现金只可能为-pricie[i]，因为只有一次买入机会，不能继承之前买入的财产。==

2. 如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来
- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]
- 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0]

**初始条件：**
将第一天进行初始化

**遍历顺序：**
从左到右吧

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));
        dp[0][0] = -prices[0]; // 0为持有股票的最大金钱
        dp[0][1] = 0;          // 1为不持股票的最大金钱
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i - 1][0], - prices[i]);
            dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
        }
        return dp[n - 1][1];
    } 
};
```
## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
### **思路**
此题由于可以多次交易，因此和121只有递推部分有区别，那就是当买入股票时，应该可以继承上一次已经赚钱的部分，即可以是
dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); 这一点十分重要。其余完全一样。
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
        }
        return dp[n - 1][1];
    }
};
```
## [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
### **思路**
首先明确一条规则，**可以在同一天买入又卖出**，这条规则是不是影响最终结果的，但是可以辅助构造出dp数组和递推律。若不能在一天买入卖出的话，第二次买入卖出的状态是不可能出现的，假如没有完成第一次交易的话。

**dp[i][j]**
确定dp数组以及下标的含义
一天一共就有五个状态，
    j =
0, 没有操作
1, 第一次买入
2, 第一次卖出
3, 第二次买入
4, 第二次卖出

**状态转移**
达到dp[i][1]状态，有两个具体操作：

操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]
操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]
那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？

一定是选最大的，所以 dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);

同理dp[i][2]也有两个操作：

操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]
操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]
所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])

同理可推出剩下状态部分：

dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);

dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);

**初始化**
第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;

第0天做第一次买入的操作，dp[0][1] = -prices[0];

第0天做第一次卖出的操作，这个初始值应该是多少呢？

首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，

从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。

所以dp[0][2] = 0;

第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？

**==第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了==**，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。

所以第二次买入操作，初始化为：dp[0][3] = -prices[0];

**遍历顺序**
时间顺序遍历即可。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        /*i: day j: 0:无操作 1:第一次买入 2:第一次卖出 3:第二次买入 4:第二次卖出 */
        vector<vector<int>> dp(n, vector<int>(5));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];/*由题意可知，第0天存在该存在，那么就允许有在一天既买又卖的存在，第0天买入又卖出，那么再买入第二次即可*/
        dp[0][4] = 0;
        for (int i = 1; i < n; ++i) {
            /*第二天也无操作，则继承上一无操作状态*/
            dp[i][0] = dp[i - 1][0]; 
            /*第一次买入的状态, 由上次买入状态或是无状态(本次购买)得到*/
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); 
            /*第一次卖出的状态，可以由上次第一次卖出或是上次的买入状态得到*/
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]); 
            /*只能从上次的第二次买入和第一次卖出得到*/
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); 
            /*只能从上次的第二次卖出和第二次买入得到*/
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]); 
        }
        return dp[n - 1][4];
    }
};
```
## [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)
### **思路**
III的加强版。直接类比的方法做即可。
定义 2k + 1 个状态， 其中 0 为无操作， 1 买入， 2 卖出。
观察III可知，0->0,  0,1->1 , 1,2->2, 2,3->3, .... 
按照这个规律写递推式子即可，初始化也按照III来即可。
```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        /*无操作 + k * (买入 1 卖出 2)*/
        vector<vector<int>> dp(n, vector<int>(2 * k + 1));
        for (int i = 1; i < 2 * k; i += 2) {
            dp[0][i] = -prices[0];
        }
        for (int i = 1; i < n; ++i) {
            for (int j = 2; j <= 2 * k; j += 2) {
                dp[i][j - 1] = max(dp[i - 1][j - 1], dp[i - 1][j - 2] - prices[i]); 
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i]); 
            }
        }
        return dp[n - 1][2 * k];
    }
};
```



## [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)
### **思路**
完全背包问题，难点是先遍历背包(字符串)还是先遍历物品(单词)。
遍历顺序的讲究：
**如果先遍历背包的话，那么在每一个背包重量都会将所有的物品考虑进去，显然此时就是需要在每一个字符串对每一个单词进行考虑**
**排列问题还是组合问题**
先遍历单词的话，对于每个字符串，只有一次匹配的机会
假如是applepenapple 和apple pen。
先遍历apple的话，只有第一个apple可以匹配成功，后面的apple匹配失败。
因此需要先遍历物品。

**dp[i]含义**
从索引i结束包括i的递增子序列的长度

**状态转移:**
位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。
j = 0 到 j = i - 1进行遍历，若 nums[i] > nums[j], 则dp[i] = dp[j] + 1, 比较0到 i - 1的最大值 即可得到dp[i] = max(dp[i], dp[j] + 1)

**初始条件：**
每个都设为1,每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是1.

**遍历循序：**
dp[i] 是有0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。

j其实就是0到i-1，遍历i的循环在外层，遍历j则在内层，代码如下：


```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        // 完全背包问题
        unordered_set<string> hashTable;
        for (auto &ref: wordDict) {
            hashTable.insert(ref);
        }
        int n = s.size();
        vector<bool> dp(n + 1, false);
        dp[0] = true;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < wordDict.size(); ++j) {
                int len = wordDict[j].size();
                if (i >= len) {
                    string str = s.substr(i - len, len);
                    // cout << str << endl;
                    if (hashTable.count(str) > 0 && dp[i - len]) {
                        dp[i] = true;
                    }
                }
            }
        }
        return dp[n];
    }
};
```
## [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)
### **思路**
维持两个dp[j]数组，表示以j结尾的子串的最大值或最小值，正负均可。

**dp[i]含义**
表示以j结尾的子串的最大值和最小值

**状态转移:**
两个变化方向：以该数结尾或是该数加上前面dp[j-1]的子串

**初始条件：**
dp[0] = nums[0]即可

**遍历循序：**
从左到右

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        vector <int> maxF(nums), minF(nums); // 最大值和最小值
        for (int i = 1; i < nums.size(); ++i) {
            maxF[i] = max(maxF[i - 1] * nums[i], max(nums[i], minF[i - 1] * nums[i]));
            minF[i] = min(minF[i - 1] * nums[i], min(nums[i], maxF[i - 1] * nums[i]));
        }
        return *max_element(maxF.begin(), maxF.end());
    }
};

```

## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)
### **思路**

**dp[i]含义**
考虑第i个（包括i个）以内的房屋，最多可以偷窃的金额为dp[i]

**状态转移:**
两个变化方向：以该数结尾或是该数加上前面dp[j-1]的子串

**初始条件：**
dp[0] = 0, 便于第二天的迭代
dp[1] = nums[0]

**遍历循序：**
从左到右

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n + 1, 0);
        dp[0] = 0;
        dp[1] = nums[0];
        for (int i = 2; i <= n; ++i) {
            /* 偷(dp[i - 2])与不偷(dp[i - 1])， */
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1]);
        }
        return dp[n];
    }
};
```
## [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)
### 思路
怎么解决环的问题-> 解决首尾选择的问题 -> 分解为两部分
* 考虑首不考虑尾
![image.png](https://note.youdao.com/yws/res/3915/WEBRESOURCEdae23f5e0e316fa76f9058c8bea74bd0)
* 考虑尾不考虑首
![image.png](https://note.youdao.com/yws/res/3917/WEBRESOURCE7c3a026267106de38c7aefd1f1e3f994)

```cpp
class Solution {
public:
    /*传入 [left-right]*/
    int rangeRob(vector<int>& nums, int left, int right) {
        int n = right - left + 1;
        vector<int> dp(n + 1);
        dp[0] = 0;
        dp[1] = nums[left];
        for (int i = 2; i <= n; ++i) {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[left + i - 1]);
        }
        return dp[n];
    }
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];
        return max(rangeRob(nums, 0, n - 2), rangeRob(nums, 1, n - 1));
    }
};
```
## [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)
### **思路**
dp[i]
对应于该节点(0: 不打劫 1: 打劫) 的最大收入

**==终止条件==**
```
root == nullptr， return {0, 0}
```
**递归函数的输入和返回**
返回vector<int> dp[2],
输入 TreeNode*

**状态转移(单层递归逻辑)**
根据左右节点的最大收入，偷的话 ：dpL[0] + dpL[0] + root->val
不偷的话： max(dpL[0], dpL[1]) + max(dpR[0], dpR[1])

**初始化**
dp数组不用初始化

**遍历顺序**
显然要知道左右结果才能推断该节点的状态，必然为后续遍历


```cpp
class Solution {
public:
    vector<int> traverse(TreeNode *root) {
        if (root == nullptr) return {0, 0};
        vector<int> dpL = traverse(root->left);
        vector<int> dpR = traverse(root->right);
        vector<int> dpM{max(L[0], L[1]) + max(R[0], R[1]), root->val + L[0] + R[0]};
        return M;
    }
    int rob(TreeNode* root) {
        vector<int> res = traverse(root);
        return max(res[0], res[1]);
    }
};
```
## [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)
### **思路**

**dp[i][j]含义**
以[i,j]为右下角的最大正方形长度。

**状态转移:**
![image.png](https://note.youdao.com/yws/res/2973/WEBRESOURCE797c918abecd3efb01ce5cf6ed953b91)
其中绿色的由紫色、黑色、红色的矩形决定的。如果是边缘的话 直接设为1即可。

**初始条件：**
都设置为0

**遍历循序：**
左上到右下。

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return 0;
        }
        int maxSide = 0;
        int rows = matrix.size(), columns = matrix[0].size();
        vector<vector<int>> dp(rows, vector<int>(columns));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }
                    maxSide = max(maxSide, dp[i][j]);
                }
            }
        }
        int maxSquare = maxSide * maxSide;
        return maxSquare;
    }
};
```
## [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)
### **思路**

**dp[i]含义**
n=i时的最小完全平方数的个数，比如说12 = 4 + 4 + 4个数为3 dp[12] = 3

**状态转移:**
背包问题，就是 dp[j - i * i] + 1 为更新状态，每次取最小即可  

**初始条件：**
由于是求最小，因此把初始值先设为INT_MAX

**遍历循序：**
先背包，先物品都一样，因为并没有让你去组合数或是排列数。

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i++) { // 遍历物品
            for (int j = 1; j <= n; j++) { // 遍历背包
                if (j - i * i >= 0) {
                    dp[j] = min(dp[j - i * i] + 1, dp[j]);
                }
            }
        }
        return dp[n];
    }
};
```


## [300.最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
### **思路**
**dp[i]含义**
从索引i结束包括i的递增子序列的长度

**状态转移:**
位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。
j = 0 到 j = i - 1进行遍历，若 nums[i] > nums[j], 则dp[i] = dp[j] + 1, 比较0到 i - 1的最大值 即可得到dp[i] = max(dp[i], dp[j] + 1)

**初始条件：**
每个都设为1,每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是1.

**遍历循序：**
dp[i] 是有0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。

j其实就是0到i-1，遍历i的循环在外层，遍历j则在内层，代码如下：

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        dp[0] = 1;
        int res = 1;
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

## [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
### **思路**

**dp[i][j]含义**
dp[i][j]: i为某天的状态 j为状态: 0 买入状态 1 今天卖出状态 2 前几天卖出状态(度过了冷冻期) 3 冷冻期; 值代表最大利

**状态转移:**
转移为买入状态：1.保持之前的买入状态 2. 前几天卖出了且过了冷冻期在今天买入 3. 冷冻期买入
0,2,3->0
转移为卖出状态：1.从买入到买入
0->1
转移为前几天卖出状态(度过了冷冻期)：1.昨天为冷冻期，今天刚解冻 2. 前几天已经成功解冻
3，2->2
转移为冷冻期：1.昨天刚卖出
1->3

**初始条件：**
买入设为-prince[0]

**遍历循序：**
按时间顺序遍历即可

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        /*dp[i][j]: i为某天的状态 
        j为状态: 0 买入状态 1 今天卖出状态 2 前几天卖出状态(度过了冷冻期) 3 冷冻期; 
        值代表最大利润*/
        vector<vector<int>> dp(n, vector<int>(4));
        dp[0][0] = -prices[0];
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i - 1][0],(max(dp[i - 1][2], dp[i - 1][3]) - prices[i]));
            dp[i][1] = dp[i - 1][0] + prices[i];
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][3]);
            dp[i][3] = dp[i - 1][1];
        }
        return *max_element(dp[n - 1].begin(), dp[n - 1].end());
    }
};
```

## [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)
### **思路**
逆向思维，从戳气球变为从两端为1的范围的内添加气球，使得添加后的值最大。
可以看如下例子。 3 8的气球。那么实际的题意则是在 1  * * 1的 星号里添加 3 和 8，使得最后结果最大， 主要需要判断的是先加 3 还是 先加 8.
比如说1 3 * 1 -> 1 3 8 1-> 结果是3 + 24 = 27
比如说1 * 8 1 -> 1 3 8 1-> 结果是8 + 24 = 32
显然后者要更优。
利用分治的思想可知，对于任意两个边界i * * * * * j, 其中可以选mid为 * 中的多个。可以遍历五次 * 来max最大值。
但是前提是要已知 [i, mid] 和 [mid, j]。 则可以根据 dp 来选择。

**dp[i][j]**
以 i 和 j 为边界添加气球的最大值

**转移方程**
dp[i][j] = max(dp[i][j], dp[i][mid] + dp[mid][j] + ballon[mid] * ballon[i] * ballon[j]);

**初始化**
全部初始化为0因为[i, i] 和 [i, i + 1]都为 0.

**遍历顺序**
这个比较重要，观察下图，可知，[i, mid] + [mid, j] => [i, j];
那么必须要先知道左侧的[i, i + 2] [i, i + 3] ... + [j - 2, j] [j - 3, j]...
则 左边界需要**从左向右**遍历
右边界则需要**从左向右**遍历

![image.png](https://note.youdao.com/yws/res/3207/WEBRESOURCE4fd1ec6ab3651a502215c96ceeaea0c3)

```cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        vector<int> ballon(n + 2, 1);
        for (int i = 1; i <= n; ++i) {
            ballon[i] = nums[i - 1];
        }
        vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));
        for (int i = n; i >= 0; --i) { // 从下往上
            for (int j = i + 2; j <= n + 1; ++j) { // 从左到右
                for (int mid  = i + 1; mid < j; ++mid) {
                    dp[i][j] = max(dp[i][j], dp[i][mid] + dp[mid][j] + ballon[mid] * ballon[i] * ballon[j]);
                }
            }
        }
        // for (int i = 0; i <= n+1; ++i) { // 从下往上
        //     for (int j = 0; j <= n+1; ++j) { // 从左到右
        //         cout << dp[i][j] << ",";
        //     }
        //     cout << endl;
        // }
        return dp[0][n + 1];
    }
};
```

## [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)
### 思路
完全背包问题，
**dp[i]**
凑成总金额为 i 所需的最小硬币数.

**状态转移**
如果能装下， 判断装与装之前谁更新就选谁

**初始化**
首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;
考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。
所以下标非0的元素都是应该是最大值。

**遍历顺序**
完全背包的遍历顺序即可。

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for(int i = 0; i < coins.size(); i++) {
            for(int j = coins[i]; j <= amount; j++) {
                if(dp[j - coins[i]] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - coins[i]] + 1);    
                }
            }
        }
        return dp.back() == INT_MAX? -1: dp.back();
    }
};
```

## [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change/)
### 思路
**组合的情况**
和排列相反， 每种只考虑一次，那就是一个物品，把所有重量都遍历完即可。
```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1);
        dp[0] = 1;
        /*完全背包 组合数 先横 再竖*/
        for (int i = 0; i < coins.size(); ++i) {
            for (int j = 0; j <= coins[i]; ++j) {
                if (j >= coins[i]) {
                    dp[j] += dp[j - coins[i]];
                }
            }
        }
        return dp[amount];
    }
};
```

**排列的情况**
从图可知 [2, 3]位置的值 是由 [1, 3] 和 [1, 1]得到，其中 2 被反复考虑。
第一次被考虑 是在 [1, 3] 此时包含了 1 , 1,  **1**  和 2 , **1** ，此时加粗表示这里的 1 是在本层进行添加的. 正式由于 1， 2在各个重量反复被考虑，因此引入了排列性.
第二次被考虑 是在[2, 3]，此时 找 [1, 1]即可， 1, **2**.
![image.png](https://note.youdao.com/yws/res/3868/WEBRESOURCEa7b22231ce5606882be9cc13e323fe74)


```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1);
        dp[0] = 1;
        /*完全背包 组合数 先横 再竖*/
        for (int j = 0; j <= amount; ++j) {
            for (int i = 0; i < coins.size(); ++i) {
                if (j >= coins[i]) {
                    dp[j] += dp[j - coins[i]];
                }
            }
        }
        return dp[amount];
    }
};
```
## [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)
### 思路

思路1直接计数，可以用Brian Kernighan 算法
![image.png](https://note.youdao.com/yws/res/3080/WEBRESOURCE55960d6e80bea1f59445321d08179c53)
```cpp
class Solution {
public:
    int countOnes(int x) {
        int ones = 0;
        while (x > 0) {
            x &= (x - 1); //该运算将 xx 的二进制表示的最后一个 1 变成 0
            ones++;
        }
        return ones;
    }

    vector<int> countBits(int n) {
        vector<int> bits(n + 1);
        for (int i = 0; i <= n; i++) {
            bits[i] = countOnes(i);
        }
        return bits;
    }
};
```

### 思路2
![image.png](https://note.youdao.com/yws/res/3086/WEBRESOURCEec2955d78854a903762c2b442e4a5b0c)

dp[i]
i数字对应的1的大小

状态转移
不断更新此时的最高次幂highBit。
根据当前小于dp[i]的最大2次幂来减小问题规模：dp[i] = dp[i - highBit] + 1;

初始化
0只有0个1

遍历循序：
按从小到大

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> dp(n + 1);
        int highBit = 0;
        dp[0] = 0;
        for (int i = 1; i <= n; ++i) {
            if ((i & (i - 1)) == 0) { // 判断是否为2的整数幂
                highBit = i;
            }
            dp[i] = dp[i - highBit] + 1;
        }
        return dp;
    }
};
```
## [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)
### 思路
**dp[i]**
拆分 i 得到的最大乘积

**状态转移**
将 i = j * (i - j). 从 j =  1 ~ i - 1遍历出一个最大结果 j * dp[i - j]
**容易忽视的一点**: j * (i - j), i - j不拆分的情况容易被忽视。 

**初始化**
dp[1] = 1

**遍历顺序**
从左到右

```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[1] = 1;
        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= i - 1; ++j) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```

## [377. 组合总和](https://leetcode-cn.com/problems/combination-sum-iv/)
### 思路

完全背包问题，需要求的是排列。
如果是排列内循环一定是每个物品，因为只有这样每个物品在每一个重量下的背包才会被同时考虑。
如果是内循环是背包的话，那么每个物品在每个重量只会被考虑一次。

比如说[1, 2, 3]  target = 4
内循环为背包，见下图，则是按照每一行进行扩展，1对应的1行是仅仅考虑1的情况，2对应的每一行仅仅是在1的基础上增加了2的情况，必然只有先有1再有2，每个物品的顺序都是固定的，那就相当于没有顺序，此时的数量没有包含==先有2 再有1的情况==。
![image.png](https://note.youdao.com/yws/res/2824/WEBRESOURCE8235e75ef66e765e0d72f707206027cb)
如果内循环为物品的话，加下图，每一个重量都把所有的物品进行了考虑，比如说对应重量为3的时候，此时添加1 添加2 添加3，可以得到把之前的(1; 1,1; 2考虑进去)都可以把每个物品的添加顺序考虑进去。
![image.png](https://note.youdao.com/yws/res/2840/WEBRESOURCE5238a8a9ae4e2721dfe0244fa1b19b93)

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1);
        dp[0] = 1;
        for(int i = 0; i <= target; i++) {
            for(int j = 0; j < nums.size(); j++) {
                if(i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) { // 有个测例会溢出
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp.back();
    }
};
```
## [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)
### 思路
问题转换为0-1背包问题。
先求整个集合的和，如果和为奇数，显然不可能分割成两部分相同的，则return false。
则可以转换为0-1背包问题， 背包大小为sum/2， 物品为数字， 判断是否最后可以把背包装满。


**dp[i]含义**
dp[i]: 背包大小为 i 最多能装的数字的重量。

**状态转移:**
加入该 j 物品后， 最大重力
dp[i] = max(dp[i], dp[i - nums[j]] + nums[j])

**初始条件：**
先把第一个物品进行初始化，然后从 j 从 0 到 m - 1进行遍历

**遍历循序：**
**重要部分: ** 应该先遍历物品！！
理解： 当 dp[i - nums[j] 时， 此时的结果应该包括0 到 j - 1物品的情况， 那么就应该先把 0 到 j - 1的所有背包情况进行遍历。


```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (int i = 0; i < nums.size(); ++i) {
            sum += nums[i];
        }
        if (sum % 2 == 1) {
            return false;
        }
        int n = nums.size(), m = sum / 2;
        vector<int> dp(m + 1, 0);
        for (int i = m - 1; i >= 1; --i) {
            if (i >= nums[0]) {
                dp[i] = nums[0];
            }
        }
        for (int j = 1; j < n; ++j) {
            for (int i = m; i >= 1; --i) {
                if (nums[j] <= i) {
                    dp[i] = max(dp[i], dp[i - nums[j]] + nums[j]);
                }
            }
        }
        return dp[m] == m;
    }
};
```
## [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)
### 思路
本质上是0-1背包问题， 只不过背包的容易变为了两维，需要满足背包的 0 个数要求 和 1 个数要求。
**dp[i][j]**
0的个数为 i，1 的个数为 j的背包最多能装的字符串个数

**状态转移**
dp[i][j] 可以根据 dp[i - num_0][j - num_1]转移得到，比较是否需要添加即可。大则加之。

**初始状态**
如果没有物体的话， 应该都为 0. 即初始化为 0 即可。

**遍历顺序**
0 - 1背包，一定是先搜背包，再搜物品。
反之，比如说 物品为s[0,1,2,3,4], 搜物品的 s[1]时， s[0]的较小的背包对应的情况还未考虑，显然错误。 
```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (const auto &s: strs) {
            int sum_1 = 0, sum_0 = 0;
            for (const auto &c: s) {
                if (c == '0') {
                    sum_0++;
                } else {
                    sum_1++;
                }
            }
            for (int i = m; i >= 0; --i) {
                for (int j = n; j >= 0; --j) {
                    if (i >= sum_0 && j >= sum_1) { /*判断是否可以加进去*/
                        /*若可以加进去，取加之前和加之后最大值*/
                        dp[i][j] = max(dp[i][j], dp[i - sum_0][j - sum_1] + 1);
                    }
                }
            }
        }
        return dp[m][n];
    }
};
```
## [494. 目标和](https://leetcode-cn.com/problems/target-sum/)
### 思路
**转换为0 - 1背包 求 组合数 （求排列数的题暂时没发现）**
![image.png](https://note.youdao.com/yws/res/3815/WEBRESOURCE048aec2b25552e27f8bbb5c26be37099)
**特殊情况**
1. S + sum 为奇数， 则 x 必须小数才满足条件，显然不行，因为都为物品均为整数。
2. target 绝对值大于 sum，说明全为背包全为正数也不行，此时是最大情况。

**按照基本的一维数组的01背包的方法求解即可**
dp数组的含义：dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法
确定递推公式：填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。若 j = 5.
例如：dp[j]，j 为5，

- 已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。
- 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。
- 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]
- 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]
- 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 dp[5]
那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。
```cpp
dp[j] += dp[j - nums[i]]
```
**dp数组如何初始化**

从递归公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递归结果将都是0。

dp[0] = 1，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品。

dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。

**确定遍历顺序**
先右到左遍历，再从上到下，否则左侧都未更新，右下的结果必然出错。

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for(auto &ref: nums) {
            sum += ref;
        }
        if((sum + target) % 2 == 1 || abs(target) > sum) {
            return 0;
        }
        int x = (sum + target) / 2;
        vector<int> dp(x + 1);
        dp[0] = 1; 
        for(int i = 0; i < nums.size(); i++) {
            for(int j = x; j >= 0; j--) {
                if(j - nums[i] >= 0) {
                    dp[j] += dp[j - nums[i]];
                }
            }
        }
        return dp.back();
    }
};
```

## [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)
### 思路
dp[i] = dp[i - 1] + dp[i - 2];
```cpp
class Solution {
public:
    int fib(int n) {
        if (n == 0 || n == 1) return n;
        vector<int> dp(n + 1);
        dp[1] = 1;
        for (int i = 2; i <= n; ++i) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

## [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)
### 思路
1.确定dp数组（dp table）以及下标的含义布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。

2.确定递推公式 在确定递推公式时，就要分析如下几种情况。

整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。

当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。

当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况

情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
情况二：下标i 与 j相差为1，例如aa，也是文子串
情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。

3. dp数组如何初始化
dp[i][j]可以初始化为true么？ 当然不行，怎能刚开始就全都匹配上了。

所以dp[i][j]初始化为false。

4. **确定遍历顺序**
遍历顺序可有有点讲究了。
首先从递推公式中可以看出，情况三是根据dp[i + 1][j - 1]是否为true，在对dp[i][j]进行赋值true的。
dp[i + 1][j - 1] 在 dp[i][j]的左下角，如图：
![image.png](https://note.youdao.com/yws/res/2783/WEBRESOURCEbc8ca3ea42a2ff788e132bae6371ab9d)
从==左下向右上==进行遍历。
![image.png](https://note.youdao.com/yws/res/2781/WEBRESOURCE81380041795aa131562ac069be78dbb7)
```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int sz = s. size();
        vector<vector<int>> dp(sz, vector<int>(sz, 0));
        int count = 0;
        for(int i = sz - 1; i >= 0; i--) {
            for(int j = i; j < sz; j++) {
                if(s[i] == s[j]) {
                    if(j - i <= 1) {
                        count++;
                        dp[i][j] = 1;
                    }else {
                        if(dp[i + 1][j - 1] == 1) {
                            count++;
                            dp[i][j] = 1;
                        }
                    }
                }
            }
        }
        return count;
    }
};
```
## [516.最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)
### 思路
序列可以要求不连续。
1. 确定dp数组（dp table）以及下标的含义:  dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。
2. 确定递推公式:如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2;如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子串的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。
**加入s[j]的回文子序列长度为dp[i + 1][j]。**

**加入s[i]的回文子序列长度为dp[i][j - 1]。**

**那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);**
3. 首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] = dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。

所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。

其他情况dp[i][j]初始为0就行，这样递推公式：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); 中dp[i][j]才不会被初始值覆盖。
4. 确定遍历顺序
从递推公式dp[i][j] = dp[i + 1][j - 1] + 2 和 dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) 可以看出，dp[i][j]是依赖于dp[i + 1][j - 1] 和 dp[i + 1][j]，

也就是从矩阵的角度来说，dp[i][j] 下一行的数据。 所以遍历i的时候一定要从下到上遍历，这样才能保证，下一行的数据是经过计算的。

递推公式：dp[i][j] = dp[i + 1][j - 1] + 2，dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) ，如图：
![image.png](https://note.youdao.com/yws/res/2773/WEBRESOURCE83faee090bd870fa19a7f3b26b9c2e9c)
遍历方向有三种，左到右，下到上，左下到右上，因此得确保下和左的已经有结果。
```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int sz = s.size();
        vector<vector<int>> dp(sz, vector<int>(sz, 0));
        for(int i = sz - 1; i >= 0; i--) {
            for(int j = i; j < sz; j++) {
                if(s[i] == s[j]) {
                    if(j - i == 0) {
                        dp[i][j] = 1;
                    }else if(j - i == 1) {
                        dp[i][j] = 2;
                    }else {
                        dp[i][j] = dp[i + 1][j - 1] + 2;
                    }
                }else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][sz - 1];
    }
};
```

## [674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)
### 思路
dp[i]
以索引i结尾的最长连续递增序列的长度

状态转移
如果 i 对应的nums 大于前一位的话，那么在前 1 位的基础上 + 1即可. 

初始化
dp[0] = 1, 第一个必然为 1.

遍历顺序
从左到右

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        /*以 i 结尾的最长递增连续子序列*/
        vector<int> dp(n);
        dp[0] = 1;
        int res = 1;
        for (int i = 1; i < n; ++i) {
            if (nums[i] > nums[i - 1]) {
                dp[i] = dp[i - 1] + 1;
            } else {
                dp[i] = 1;
            }
            res = max(res, dp[i]);
        }
        return res;
    }
};
```
## [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)
### 思路

dp[i][j]
以 i-1 , j-1结尾的 nums1和nums2的最长公共长度

状态转移
nums[i-1] == nums[j-1] -> dp[i][j] = dp[i-1][j-1] + 1; else 为 0.

初始化
全部 0 即可.

遍历顺序
从左上到右下

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        int res = 0;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    res = max(res, dp[i][j]);
                }
            }
        }
        return res;
    }
};
```
![image.png](https://note.youdao.com/yws/res/3997/WEBRESOURCE7fddf971f5b84f19a8f9bdefd7e037ba)
可以发现都是从上到下递增， 那么可以用滚动数组进行优化.
**注意需要倒序遍历， 防止新的把之前dp[j-1]覆盖掉**
```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();
        vector<int> dp(n + 1);
        int res = 0;
        for (int i = 1; i <= m; i++) {
            for (int j = n; j >= 1; --j) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[j] = dp[j - 1] + 1;
                } else {
                    dp[j] = 0;
                }
                res = max(res, dp[j]);
            }
        }
        return res;
    }
};
```

## [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)
### 思路
dp[i]含义
到达索引 i 处的最小花费。

状态转移
可以根据是由爬两梯 或是 爬一梯 转移得来。

初始化
初始化第 0、 第 1 索引的值

遍历方向
从左到右

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> dp(n);
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i < n; ++i) {
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        return min(dp[n - 1], dp[n - 2]);
    }
};
```
## [931. 下降路径最小和](https://leetcode-cn.com/problems/minimum-falling-path-sum/)
### 思路
dp[i][j]含义
到达 matrix[i, j] 索引花费的最小和

状态转移:
![image.png](https://note.youdao.com/yws/res/3739/WEBRESOURCE399816a67199d046770cef5eeb7590e9)

初始条件：
第一行初始化为matrix[0]

遍历循序：
依据递推公式可知
从上到下，从左到右。

```cpp
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> dp(m, vector<int>(n));
        dp[0] = matrix[0];
        for (int i = 1; i < m; ++i) {
            /*第一列*/
            dp[i][0] = min(dp[i - 1][0], dp[i - 1][1]) + matrix[i][0];
            /*2 ~ n-1*/
            for (int j = 1; j < n - 1; ++j) {
                dp[i][j] = min(dp[i - 1][j], min(dp[i - 1][j - 1], dp[i - 1][j + 1])) + matrix[i][j];
            }
            /*第n列*/
            dp[i][n - 1] = min(dp[i - 1][n - 1], dp[i - 1][n - 2]) + matrix[i][n - 1];
        }
        return *min_element(dp[m - 1].begin(), dp[m - 1].end());
    }
};
``` 
## [1035. 不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)
### 思路
绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且直线不能相交！

直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。

拿示例一A = [1,4,2], B = [1,2,4]为例，相交情况如图：
![image.png](https://note.youdao.com/yws/res/4030/WEBRESOURCE88aab15d01236775ca3cc511a09ca862)
这么分析完之后，大家可以发现：**本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！**
和 1143 题一样.
```cpp
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp(nums2.size() + 1, vector<int>(nums1.size() + 1));
        for(int i = 1; i <= nums2.size(); i++) {
            for(int j = 1; j <= nums1.size(); j++) {
                if(nums2[i - 1] == nums1[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp.back().back();
    }
};
```

## [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)
### 思路
类似 718. 最长重复子数组
子序列可以不连续. 那么dp的定义就需要放宽松点了

dp[i][j]
以字符串 i - 1, j - 1的范围可以构成的最长公共子序列的最长长度， 这样的定义不需要强制要求公共序列是由结尾元素组成的。

状态转移
若 nums[i - 1] == nums[j - 1], dp[i][j] = dp[i-1][j-1] + 1.
若不等的话，那必然是由之前推导出的结果 dp[i-1][j] 和 dp[i][j-1]中较大的构成，元素的个数越多，则越最长公共序列的可能性越大，必然在这两者之间选择，dp[i-1][j-1]已经包含在上述两种情况之内。

初始化
全为 0 即可， 可以让边界值为 0.

遍历顺序
从小到大遍历，因为都是由较小状态获取得到。

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        int res = 0;
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
                res = max(res, dp[i][j]);
            }
        }
        return res;
    }
};
```

## [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)
### 思路
0 - 1 背包， 将题转化为是否能填满重量之和的一半对应的背包。
0 - 1 背包： 先物品再背包、 从右到左遍历背包(确保每块石头只加入一次)。
dp[i]含义是 i 大小的背包最多能装多少。
```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for(auto &ref: stones) {
            sum += ref;
        }
        int n = sum / 2; // 背包重量
        vector<int> dp(n + 1); // 包括背包为 0 的情况
        /*0 - 1 背包 先物品 再背包。*/        
        for(int i = 0; i < stones.size(); i++) {
            /*0 - 1 背包， 从右到左进行遍历*/
            for(int j = n; j >=0; j--) {
                if(j - stones[i] >= 0) {
                    dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
                }
            }
        }
        return abs(sum - 2 * dp.back());    
    }
};
```